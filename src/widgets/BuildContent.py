# **************************************************************************************************
# @file BuildContent.py
# @brief Content of the CollapsileBox for the build mode. 
#
# @project   VVToolkit
# @version   1.0
# @date      2024-08-04
# @author    @dabecart
#
# @license
# This project is licensed under the MIT License - see the LICENSE file for details.
# **************************************************************************************************

from PyQt6.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QLabel, 
                            QTextEdit, QComboBox, QLineEdit)
from PyQt6.QtCore import Qt

from DataFields import Item
from widgets.CodeTextField import CodeTextField

class BuildContent(QWidget):
    def __init__(self, item : Item, parent = None) -> None:
        super().__init__(parent)

        self.item = item
        self.parent = parent

        contentLayout = QVBoxLayout(self)
        contentLayout.setAlignment(Qt.AlignmentFlag.AlignTop)

        inputCommandLabel = QLabel("Input:")
        self.inputCmdText = CodeTextField()
        self.inputCmdText.setText(self.item.runcode)
        self.inputCmdText.setReadOnly(True)
        self.inputCmdText.setStatusTip("The code that runs for this test case.")
        
        outputCommandLabel = QLabel("Output:")
        self.outputCmdIndexCombo = QComboBox()
        self.outputCmdIndexCombo.setStatusTip("Select which of the iterations to show.")
        self.outputCmdIndexCombo.setPlaceholderText("None")
        self.outputCmdIndexCombo.setMinimumHeight(30)
        self.outputCmdIndexCombo.setMinimumWidth(self.outputCmdIndexCombo.sizeHint().width() + 16)
        self.outputCmdIndexCombo.addItems([str(i) for i in range(self.item.repetitions)])
        if self.item.hasBeenRun():
            self.outputCmdIndexCombo.setCurrentIndex(0)
        else:
            self.outputCmdIndexCombo.setCurrentIndex(-1)
            self.outputCmdIndexCombo.setEnabled(False)
        self.outputCmdIndexCombo.currentTextChanged.connect(self.onOutputCmdIndexChanged)
        self.outputReturnValue = QLabel("")

        outputHeader = QWidget()
        outputHeaderLayout = QHBoxLayout(outputHeader)
        outputHeaderLayout.setContentsMargins(0,0,0,0)
        outputHeaderLayout.addWidget(outputCommandLabel)
        outputHeaderLayout.addWidget(self.outputCmdIndexCombo)
        outputHeaderLayout.addStretch()
        outputHeaderLayout.addWidget(self.outputReturnValue)

        self.outputCmdText = QTextEdit()
        self.outputCmdText.setStatusTip('The output generated by this test case.')
        if self.item.hasBeenRun():
            # This will update the text on the output cmd.
            self.outputCmdText.setText(self.item.result[0].output)
            self.outputReturnValue.setText(f"Return: {self.item.result[0].returnCode}\nExecution time: {self.item.result[0].executionTime:.2f} ms")
        self.outputCmdText.setReadOnly(True)

        checkModeLabel = QLabel("Checking Mode:")
        self.checkModeCombo = QComboBox()
        self.checkModeCombo.setStatusTip('Select which type of verification will be used for this test case.')
        self.checkModeCombo.setFixedHeight(30)
        self.checkModeCombo.addItems(["Same output", "Conditional output"])
        self.checkModeCombo.currentTextChanged.connect(self.onCheckingModeChanged)

        self.operatorCombo = QComboBox()
        self.operatorCombo.setStatusTip('Select the operation for the validation process.')
        self.operatorCombo.setFixedHeight(30)
        self.operatorCombo.addItems(["==", "<>", "<", ">", "<=", ">="])
        self.operatorCombo.setVisible(False)

        self.operatorValueEdit = QLineEdit()
        self.operatorValueEdit.setStatusTip('The value used for the validation process.')
        self.operatorValueEdit.setVisible(False)

        checkModeWidget = QWidget()
        checkModeLayout = QHBoxLayout(checkModeWidget)
        checkModeLayout.setContentsMargins(0,0,0,0)
        checkModeLayout.addWidget(checkModeLabel)
        checkModeLayout.addWidget(self.checkModeCombo)
        checkModeLayout.addWidget(self.operatorCombo)
        checkModeLayout.addWidget(self.operatorValueEdit)

        contentLayout.addWidget(inputCommandLabel)
        contentLayout.addWidget(self.inputCmdText)
        contentLayout.addWidget(outputHeader)
        contentLayout.addWidget(self.outputCmdText)
        contentLayout.addWidget(checkModeWidget)

    def isUpdated(self):
        ret =   (self.outputCmdIndexCombo.count() == self.item.repetitions) \
                and (self.inputCmdText.toPlainText() == self.item.runcode) \
                and (self.item.result and self.outputCmdText.toPlainText() != "")
        if ret:
            for res in self.item.result:
                if (self.outputCmdText.toPlainText() == res.output):
                    return True
            return False
        return ret
    
    def onOutputCmdIndexChanged(self, text):
        try:
            index = int(text)
        except ValueError:
            return
        
        result = self.item.result[index]
        self.outputCmdText.setText(result.output)
        self.outputReturnValue.setText(f"Return: {result.returnCode}\nExecution time: {result.executionTime:.2f} ms")

    def onCheckingModeChanged(self, text):
        if text == "Conditional output":
            self.operatorCombo.setVisible(True)
            self.operatorValueEdit.setVisible(True)
            # This below is not really needed.
            self.parent.mainWidget.setMaximumHeight(self.parent.mainWidget.sizeHint().height())
        else:
            self.operatorCombo.setVisible(False)
            self.operatorValueEdit.setVisible(False)
            self.parent.mainWidget.setMaximumHeight(self.parent.openedHeight)